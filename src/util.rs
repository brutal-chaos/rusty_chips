/// Copyright 2015-2023, Justin Noah <justinnoah at gmail.com>, All Rights Reserved
use regex::Regex;

pub fn test_roms() -> Vec<Vec<u8>> {
    let mut roms = Vec::new();
    let hex_to_dec = Vec::from([
        0x00, 0xE0, 0x63, 0x80, 0x64, 0x00, 0x65, 0x00, 0xA5, 0x00, 0xF3, 0x33, 0xF2, 0x65, 0xF0,
        0x29, 0xD4, 0x55, 0xF1, 0x29, 0x74, 0x08, 0xD4, 0x55, 0xF2, 0x29, 0x74, 0x08, 0xD4, 0x55,
        0xF0, 0x00,
    ]);
    roms.push(hex_to_dec);
    let little_lamb = Vec::from([
        0x65, 0x00, 0xA3, 0x00, 0x75, 0x01, 0x22, 0x10, 0x35, 0x23, 0x12, 0x04, 0xF0, 0x00, 0x00,
        0x00, 0x60, 0x00, 0x61, 0x00, 0x62, 0x01, 0xF0, 0x65, 0xF0, 0x17, 0xF1, 0x18, 0xF2, 0x1E,
        0x63, 0xF4, 0x64, 0x00, 0x74, 0x01, 0x34, 0xFF, 0x12, 0x22, 0x73, 0x01, 0x33, 0xFF, 0x12,
        0x20, 0x00, 0xEE, 0x11, 0x10, 0x0F, 0x10, 0x11, 0x11, 0x11, 0x00, 0x00, 0x10, 0x10, 0x10,
        0x00, 0x11, 0x13, 0x13, 0x00, 0x00, 0x11, 0x10, 0x0F, 0x10, 0x11, 0x11, 0x11, 0x00, 0x00,
        0x11, 0x10, 0x10, 0x11, 0x10, 0x0F, 0x00, 0x00, 0x00,
    ]);
    roms.push(little_lamb);
    roms
}

fn input_to_hertz(input: &str) -> u128 {
    let re_num = Regex::new(r"\d+(\.\d+)?").unwrap();
    let num_range: (usize, usize) = {
        let matches = re_num.find(input).unwrap();
        (matches.start(), matches.end())
    };
    let number: f64 = input[num_range.0..num_range.1].trim().parse().unwrap();
    let freq = input[num_range.1..].to_string().to_lowercase();
    let multiplier = match freq.as_str() {
        "ghz" => 1000 * 1000,
        "mhz" => 1000,
        "hz" => 1,
        _ => panic!("Chip8 Frequency must end with GHz, MHz, or Hz"),
    };
    let frequency_in_hertz = number * (multiplier as f64);
    frequency_in_hertz.floor() as u128
}

fn hertz_to_seconds(hertz: u128) -> f64 {
    1f64 / (hertz as f64)
}

pub fn hz_to_secs(input: &str) -> f64 {
    hertz_to_seconds(input_to_hertz(input))
}
